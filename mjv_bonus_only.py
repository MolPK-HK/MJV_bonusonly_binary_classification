# -*- coding: utf-8 -*-
"""MJV_Webã‚¢ãƒ—ãƒª_å°å½¹ãªã—.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sjrqnVyFEAPvZCJ7hkdlUFi62WnXjOIc
"""

import streamlit as st
import pandas as pd
import numpy as np
import joblib
import os
import xgboost as xgb # ãƒ¢ãƒ‡ãƒ«ãŒXGBoostã®å ´åˆã€æ¨è«–æ™‚ã«ã‚‚å¿…è¦ã«ãªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™

# --- å®šæ•°å®šç¾© (ãƒ¢ãƒ‡ãƒ«è¨“ç·´æ™‚ã¨åŒã˜ã‚‚ã®ã‚’ä½¿ç”¨) ---
MEDALS_PER_GAME_COST = 3
REPLAY_PROBABILITY = 1 / 7.3  # ãƒã‚¤ã‚¸ãƒ£ã‚°ãƒ©ãƒ¼Vã®ä¸€èˆ¬çš„ãªãƒªãƒ—ãƒ¬ã‚¤ç¢ºç‡
PAYOUT_BIG_GROSS = 252      # BIGãƒœãƒ¼ãƒŠã‚¹1å›ã‚ãŸã‚Šã®ç·ç²å¾—æšæ•°
PAYOUT_REG_GROSS = 96       # REGãƒœãƒ¼ãƒŠã‚¹1å›ã‚ãŸã‚Šã®ç·ç²å¾—æšæ•°

@st.cache_data # ç‰¹å¾´é‡è¨ˆç®—é–¢æ•°ã‚‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥å¯èƒ½ã§ã™ãŒã€å…¥åŠ›ãŒå¤‰ã‚ã‚‹ãŸã³ã«å†è¨ˆç®—ãŒå¿…è¦ãªã®ã§ã“ã“ã§ã¯ä¿ç•™
def preprocess_inputs_for_streamlit(input_data_dict):
    """
    ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã®è¾æ›¸ï¼ˆ4ã¤ã®åŸºæœ¬æƒ…å ±ï¼‰ã‹ã‚‰ã€ãƒ¢ãƒ‡ãƒ«äºˆæ¸¬ã«å¿…è¦ãª5ã¤ã®ç‰¹å¾´é‡ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã€‚
    """
    df = pd.DataFrame([input_data_dict])

    required_keys_type = {
        'num_games_simulated': int,
        'bb_count': int,
        'rb_count': int,
        'sashimai': int
    }
    for key, expected_type in required_keys_type.items():
        if key not in df.columns or pd.isna(df[key].iloc[0]):
            st.error(f"å…¥åŠ›ã‚¨ãƒ©ãƒ¼: '{key}' ã®å€¤ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚")
            return None
        try:
            df[key] = df[key].astype(expected_type)
        except ValueError:
            st.error(f"å…¥åŠ›ã‚¨ãƒ©ãƒ¼: '{key}' ã®å€¤ãŒä¸æ­£ã§ã™ã€‚é©åˆ‡ãªæ•°å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚")
            return None
        if key == 'num_games' and df[key].iloc[0] <= 0:
            st.error(f"å…¥åŠ›ã‚¨ãƒ©ãƒ¼: '{key}' ã¯æ­£ã®æ•´æ•°ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚")
            return None

    # --- 5ã¤ã®åŸºæœ¬ç‰¹å¾´é‡ã®è¨ˆç®— ---
    # 'num_games' ã¯å…¥åŠ›ã‹ã‚‰ãã®ã¾ã¾ä½¿ç”¨
    df['num_games'] = df['num_games_simulated']
    df['bb_rate'] = np.where(df['num_games'] > 0, df['bb_count'] / df['num_games'], 0)
    df['rb_rate'] = np.where(df['num_games'] > 0, df['rb_count'] / df['num_games'], 0)

    df['estimated_total_medals_in'] = df['num_games'] * (1 - REPLAY_PROBABILITY) * MEDALS_PER_GAME_COST
    df['estimated_total_medals_in'] = np.where(df['num_games'] > 0, df['estimated_total_medals_in'], 0).clip(min=0)
    df['calculated_total_medals_out'] = df['sashimai'] + df['estimated_total_medals_in']

    payout_from_bonuses = (df['bb_count'] * PAYOUT_BIG_GROSS) + (df['rb_count'] * PAYOUT_REG_GROSS)
    total_payout_from_small_wins = df['calculated_total_medals_out'] - payout_from_bonuses
    df['small_win_medals_per_game'] = np.where(
        df['num_games'] > 0,
        total_payout_from_small_wins / df['num_games'],
        0
    )
    df['small_win_medals_per_game'] = df['small_win_medals_per_game'].replace([np.inf, -np.inf], np.nan).fillna(0)

    df['machine_percentage_rpm'] = np.where(
        df['estimated_total_medals_in'] > 0,
        df['calculated_total_medals_out'] / df['estimated_total_medals_in'],
        1.0
    )
    df['machine_percentage_rpm'] = df['machine_percentage_rpm'].replace([np.inf, -np.inf], np.nan).fillna(1.0)

    feature_columns = ['num_games', 'bb_rate', 'rb_rate', 'small_win_medals_per_game', 'machine_percentage_rpm']

    # ç‰¹å¾´é‡ãŒå­˜åœ¨ã—ã€NaN/infãŒãªã„ã“ã¨ã‚’ç¢ºèª
    for col in feature_columns:
        if col not in df.columns:
            st.error(f"ã‚¨ãƒ©ãƒ¼: ç‰¹å¾´é‡ '{col}' ãŒç”Ÿæˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚è¨ˆç®—éç¨‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚")
            return None
        df[col] = df[col].replace([np.inf, -np.inf], np.nan).fillna(0)

    X_transformed = df[feature_columns]
    return X_transformed

# ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹
@st.cache_resource
def load_model(model_path):
    if not os.path.exists(model_path):
        st.error(f"ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ« '{model_path}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ‘ã‚¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚")
        return None
    try:
        model = joblib.load(model_path)
        st.success(f"ãƒ¢ãƒ‡ãƒ« '{model_path}' ã‚’æ­£å¸¸ã«èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚")
        return model
    except Exception as e:
        st.error(f"ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
        return None

# --- Streamlit ã‚¢ãƒ—ãƒªã®UIéƒ¨åˆ† ---
st.set_page_config(page_title="ãƒ‘ãƒã‚¹ãƒ­è¨­å®šåˆ¤åˆ¥ã‚¢ãƒ—ãƒª", layout="wide")
st.title("ãƒã‚¤ã‚¸ãƒ£ã‚°ãƒ©ãƒ¼V è¨­å®šåˆ¤åˆ¥ã‚¢ãƒ—ãƒª (2å€¤åˆ†é¡)")
st.markdown("å…¥åŠ›ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã€è¨­å®šãŒã€Œä½ä¸­è¨­å®š(1-3)ã€ã‹ã€Œé«˜ä¸­è¨­å®š(4-6)ã€ã‹ã‚’äºˆæ¸¬ã—ã¾ã™ã€‚")

# â˜…â˜…â˜… å­¦ç¿’æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æŒ‡å®š â˜…â˜…â˜…
MODEL_FILE_PATH = 'juggler_binary_classifier_final_5features.joblib' # ã”è‡ªèº«ã®ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«åã«å¤‰æ›´

# ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚€
trained_model = load_model(MODEL_FILE_PATH)

# ã‚µã‚¤ãƒ‰ãƒãƒ¼ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã‚’å—ã‘ä»˜ã‘ã‚‹
st.sidebar.header("éŠæŠ€ãƒ‡ãƒ¼ã‚¿ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„")
num_games_input = st.sidebar.number_input("ç·ã‚²ãƒ¼ãƒ æ•°", min_value=1, value=3000, step=100, key="num_games")
bb_count_input = st.sidebar.number_input("ç·BIGå›æ•°", min_value=0, value=10, step=1, key="bb_count")
rb_count_input = st.sidebar.number_input("ç·REGå›æ•°", min_value=0, value=8, step=1, key="rb_count")
sashimai_input = st.sidebar.number_input("å·®æš (ä¾‹: +1000, -500)", value=0, step=50, key="sashimai")

# äºˆæ¸¬ãƒœã‚¿ãƒ³
if st.sidebar.button("è¨­å®šã‚°ãƒ«ãƒ¼ãƒ—ã‚’åˆ¤åˆ¥ã™ã‚‹", type="primary"):
    if trained_model is not None:
        user_inputs_dict = {
            'num_games': num_games_input, # preprocessé–¢æ•°ãŒæœŸå¾…ã™ã‚‹ã‚­ãƒ¼ã«åˆã‚ã›ã‚‹
            'bb_count': bb_count_input,
            'rb_count': rb_count_input,
            'sashimai': sashimai_input
        }

        st.markdown("---")
        st.subheader("å…¥åŠ›ãƒ‡ãƒ¼ã‚¿:")
        st.json({k: v for k,v in user_inputs_dict.items()}) # å…¥åŠ›å€¤ã‚’è¡¨ç¤º

        # ç‰¹å¾´é‡ã¸å¤‰æ›
        features_for_prediction = preprocess_inputs_for_streamlit(user_inputs_dict)

        if features_for_prediction is not None:
            st.subheader("è¨ˆç®—ã•ã‚ŒãŸç‰¹å¾´é‡ (ãƒ¢ãƒ‡ãƒ«å…¥åŠ›ç”¨):")
            st.dataframe(features_for_prediction)

            try:
                # äºˆæ¸¬ã®å®Ÿè¡Œ
                prediction_label_encoded = trained_model.predict(features_for_prediction)[0]
                predicted_probabilities = trained_model.predict_proba(features_for_prediction)[0]

                class_names = ['è¨­å®š1-3ã‚°ãƒ«ãƒ¼ãƒ— (ä½ä¸­è¨­å®š)', 'è¨­å®š4-6ã‚°ãƒ«ãƒ¼ãƒ— (é«˜ä¸­è¨­å®š)']
                predicted_class_name = class_names[prediction_label_encoded]

                st.subheader("ğŸ“ˆ äºˆæ¸¬çµæœ")
                st.markdown(f"**åˆ¤åˆ¥ã•ã‚ŒãŸã‚°ãƒ«ãƒ¼ãƒ—:** <span style='font-size:1.5em; color:blue;'>{predicted_class_name}</span>", unsafe_allow_html=True)

                col1, col2 = st.columns(2)
                with col1:
                    st.metric(label=f"'{class_names[0]}' ã§ã‚ã‚‹ç¢ºç‡", value=f"{predicted_probabilities[0]:.2%}")
                with col2:
                    st.metric(label=f"'{class_names[1]}' ã§ã‚ã‚‹ç¢ºç‡", value=f"{predicted_probabilities[1]:.2%}")

                if predicted_probabilities[1] > 0.75:
                    st.success("é«˜ä¸­è¨­å®šã‚°ãƒ«ãƒ¼ãƒ—ã®å¯èƒ½æ€§ãŒéå¸¸ã«é«˜ã„ã§ã™ã€‚")
                elif predicted_probabilities[1] > 0.60:
                    st.info("é«˜ä¸­è¨­å®šã‚°ãƒ«ãƒ¼ãƒ—ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚")
                elif predicted_probabilities[0] > 0.75:
                    st.success("ä½ä¸­è¨­å®šã‚°ãƒ«ãƒ¼ãƒ—ã®å¯èƒ½æ€§ãŒéå¸¸ã«é«˜ã„ã§ã™ã€‚")
                elif predicted_probabilities[0] > 0.60:
                    st.info("ä½ä¸­è¨­å®šã‚°ãƒ«ãƒ¼ãƒ—ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚")
                else:
                    st.warning("äºˆæ¸¬ã®ç¢ºä¿¡åº¦ã¯ä¸­é–“çš„ã§ã™ã€‚")

            except Exception as e:
                st.error(f"äºˆæ¸¬ã®å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
        else:
            st.error("ç‰¹å¾´é‡ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚å…¥åŠ›å€¤ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚")
    else:
        st.error("ãƒ¢ãƒ‡ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ä¸Šè¨˜ã®ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’ç¢ºèªã—ã€Streamlitã‚’å†èµ·å‹•ã—ã¦ãã ã•ã„ã€‚")

st.sidebar.markdown("---")
st.sidebar.markdown("ã“ã®ã‚¢ãƒ—ãƒªã¯æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«ã«ã‚ˆã‚‹äºˆæ¸¬ã§ã‚ã‚Šã€å®Ÿéš›ã®è¨­å®šã‚’ä¿è¨¼ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚")